#### 题目描述

给出一个**完全二叉树**，求出该树的节点个数。

**说明：**

[完全二叉树](https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin)的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。

**示例:**

```
输入: 
    1
   / \
  2   3
 / \  /
4  5 6

输出: 6
```





#### 题解

- **方法：二分查找 + 位运算**

  对于任意二叉树，都可以通过广度优先搜索或深度优先搜索计算节点个数，时间复杂度和空间复杂度都是 $O(n)$，其中 $n$ 是二叉树的节点个数。这道题规定了给出的是完全二叉树，因此可以利用完全二叉树的特性计算节点个数。

  规定根节点位于第 $0$ 层，完全二叉树的最大层数为 $h$。根据完全二叉树的特性可知，完全二叉树的最左边的节点一定位于最底层，因此从根节点出发，每次访问左子节点，直到遇到叶子节点，该叶子节点即为完全二叉树的最左边的节点，经过的路径长度即为最大层数 $h$。

  当 $0 \le i < h$ 时，第 $i$ 层包含 $2^i$ 个节点，最底层包含的节点数最少为 $1$，最多为 $2^h$。

  当最底层包含 $1$ 个节点时，完全二叉树的节点个数是
  $$
  \sum_{i=0}^{h-1}2^i+1=2^h
  $$
  当最底层包含 2^h2*h* 个节点时，完全二叉树的节点个数是
  $$
  \sum_{i=0}^{h}2^i=2^{h+1}-1
  $$
  因此对于最大层数为 $h$ 的完全二叉树，节点个数一定在 $[2^h,2^{h+1}-1]$ 的范围内，可以在该范围内通过二分查找的方式得到完全二叉树的节点个数。

  具体做法是，根据节点个数范围的上下界得到当前需要判断的节点个数 $k$，如果第 $k$ 个节点存在，则节点个数一定**大于或等于** $k$，如果第 $k$ 个节点不存在，则节点个数一定**小于** $k$，由此可以将查找的范围缩小一半，直到得到节点个数。

  **（巧妙）**查找最后一层节点

  1. 以 $2$ 层为例（层号为 $2$），整个树的节点数量应该在 $[4,7]$ 
  2. 利用二分查找找到最后一层中间那个编号的节点 $(4+7+1)/2=6$，则查找 $6$ 号节点
  3. $6$ 的二进制表示是 $110$
  4. 此时，层数是 $2$，那么取 $110$ 的后二位，即 $1$ 和 $0$

  1. 令 $0$ 表示向左，$1$ 表示向右，所以从 `root` 出发，先向右走，再向左走，即可找到 $6$ 号节点
  2. 再举个例子，$5$ 号元素101，取后 $2$ 层，即 $0$ 和 $1$，就是从 `root` 开始，先向左再向右，就能找到 $5$ 号节点
  3. 配合二分查找的思想，如果 $6$ 号存在，就去让左边界 `left` 变成这个数，再进行下一步查找
  4. 如果不存在，右边界 `right` 变为这个数，再进行下一步二分查找
  5. 直到最后找到那个元素，就是答案

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None


class Solution:
    def countNodes(self, root: TreeNode) -> int:
        if not root: return 0
        level = 0
        node = root.left
        while node:  # 这里获得层数
            level += 1
            node = node.left
        l = 1 << level  # 左界
        r = (l << 1) - 1  # 右界

        while l < r:
            mid = int((r + l + 1) / 2)  # 中位
            node = root
            path = 1 << (level - 1)  # 取mid号数的后几位的模板
            while node and path > 0:
                if mid & path: node = node.right
                else: node = node.left
                path >>= 1  # 一层查完，查下一层
            if node: l = mid  # 存在left位置变化
            else: r = mid - 1  # 不存在right位置变化
        return r
```

