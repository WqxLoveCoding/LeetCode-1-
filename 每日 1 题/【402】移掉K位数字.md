#### 题目描述

给定一个以字符串表示的非负整数 *num*，移除这个数中的 *k* 位数字，使得剩下的数字最小。

**注意:**

- *num* 的长度小于 10002 且 ≥ *k。*
- *num* 不会包含任何前导零。

**示例 1 :**

```
输入: num = "1432219", k = 3
输出: "1219"
解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。
```

**示例 2 :**

```
输入: num = "10200", k = 1
输出: "200"
解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。
```

示例 **3 :**

```
输入: num = "10", k = 2
输出: "0"
解释: 从原数字移除所有的数字，剩余为空就是0。
```





#### 题解

暴力法的话，我们需要枚举 $C_n^{n - k}$ 种序列（其中 n 为数字长度），并逐个比较最大。这个时间复杂度是指数级别的，必须进行优化。

一个优化思路：

- 从左到右遍历
- 对于每一个遍历到的元素，我们决定是**丢弃**还是**保留**

问题的关键是：我们怎么知道，一个元素是应该保留还是丢弃呢？

这里有一个前置知识：**对于两个数 $123a456$ 和 $123b456$，如果 $a > b$， 那么 $123a456 > 123b456$，否则 $123a456 \le 123b456$**。也就说，两个**相同位数**的数字大小关系取决于**第一个**不同的数的大小。

因此我们的思路就是：

- 从左到右遍历
- 对于遍历到的元素，我们选择保留。
- 但是我们可以选择性丢弃前面相邻的元素。
- 丢弃与否的依据如上述方法。

以题目中的 `num = 1432219， k = 3` 为例的图解过程如下：

![img](https://pic.leetcode-cn.com/36ebd489866a9fb0745bf3401f325fe0866444a52c9696be2ffec1b67eeabd0c.jpg)

由于没有左侧相邻元素，因此**没办法丢弃**。

![img](https://pic.leetcode-cn.com/09d5a8a23aa159a23031b9a6bef05598bfd5ccbbdce8dcb92984de6037cafdbe.jpg)

由于 $4$ 比左侧相邻的 $1$ 大。如果选择丢弃左侧的 $1$，那么会使得剩下的数字更大（开头的数从 $1$ 变成了 $4$）。因此我们仍然选择**不丢弃**。

![img](https://pic.leetcode-cn.com/4f08e2d93823faccf91a849425def6ed0389afaef0b41a83fb11358f36df2f45.jpg)

（图 4）

由于 $3$ 比左侧相邻的 $4$ 小。 如果选择丢弃左侧的 $4$，那么会使得剩下的数字更小（开头的数从 $4$ 变成了 $3$）。因此我们选择**丢弃**。

……

需要注意的是，如果给定的数字是一个单调递增的数字，那么我们的算法会永远**选择不丢弃**。这个题目中要求的，我们要永远确保**丢弃** $k$ 个矛盾。

一个简单的思路就是：

- 每次丢弃一次，$k$ 减去 $1$。当 $k$ 减到 $0$ ，我们可以提前终止遍历。
- 而当遍历完成，如果 $k$ 仍然大于 $0$。不妨假设最终还剩下 $x$ 个需要丢弃，那么我们需要选择删除末尾 $x$ 个元素。

上面的思路可行，但是稍显复杂。

假如把思路逆转过来。刚才的关注点一直是**丢弃**，题目要求我们丢弃 $k$ 个。反过来说，不就是让我们保留 $n-k$ 个元素么？其中 $n$ 为数字长度。 那么我们只需要按照上面的方法遍历完成之后，再截取前 $n-k$ 个元素即可。

按照上面的思路，我们来选择数据结构。由于我们需要**保留**和**丢弃相邻**的元素，因此使用栈这种在一端进行添加和删除的数据结构是再合适不过了。

```python
class Solution(object):
    def removeKdigits(self, num, k):
        stack = []
        remain = len(num) - k
        for digit in num:
            while k and stack and stack[-1] > digit:
                stack.pop()
                k -= 1
            stack.append(digit)
        return ''.join(stack[:remain]).lstrip('0') or '0'
```

**复杂度分析**

- 时间复杂度：虽然内层还有一个 `while` 循环，但是由于每个数字最多仅会入栈出栈一次，因此时间复杂度仍然为 $O(N)$，其中 $N$ 为数字长度。
- 空间复杂度：我们使用了额外的栈来存储数字，因此空间复杂度为 $O(N)$，其中 $N$ 为数字长度。

> 提示： 如果题目改成求删除 $k$ 个字符之后的最大数，我们只需要将 `stack[-1] > digit` 中的大于号改成小于号即可。

